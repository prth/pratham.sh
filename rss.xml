<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[pratham.sh]]></title><description><![CDATA[I'm a Software Engineer living in Mumbai, evolving and working on making cool things at Upstox.]]></description><link>https://pratham.sh</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 31 May 2020 21:01:14 GMT</lastBuildDate><item><title><![CDATA[A case for API client libraries in microservices architecture]]></title><description><![CDATA[In this post, I will make a case for maintaining API client libraries for inter-process communication in microservices. I will present the…]]></description><link>https://pratham.sh/a-case-for-api-client-libraries-in-microservices/</link><guid isPermaLink="false">https://pratham.sh/a-case-for-api-client-libraries-in-microservices/</guid><pubDate>Sun, 31 May 2020 20:39:30 GMT</pubDate><content:encoded>&lt;p&gt;In this post, I will make a case for maintaining API client libraries for inter-process communication in microservices. I will present the benefits they will have for a team maintaining multiple services, and how it can improve the team collaboration.&lt;/p&gt;
&lt;p&gt;Microservices architecture is quite popular. Once you have microservices, you certainly have a few internal communication mechanisms. The interaction can be synchronous, asynchronous; it can be one-to-one or even one-to-many. Developing and integrating the integration is achieved with limited hurdles, and as often the case with engineering, the maintenance and collaboration are challenging.&lt;/p&gt;
&lt;p&gt;With the teams I have worked, we often used HTTP based REST APIs for synchronous interactions. And, for asynchronous calls, we used SQS or Apache Kafka. Services were distributed across many small squads to develop and maintain. We would collaborate on inter-service dependency through postman collections or swagger documentation or a document spec with the payload details and examples.&lt;/p&gt;
&lt;p&gt;For integrating third-party external APIs, an official client library by that target service comes in convenient. So, the question is, can the same notion be applied within a company for the internal services. Here are some points in its favour, and how to implement it effectively —&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client libraries provide simple, &lt;code class=&quot;language-text&quot;&gt;intuitive to use&lt;/code&gt; interfaces.&lt;/li&gt;
&lt;li&gt;They can &lt;code class=&quot;language-text&quot;&gt;abstract the implementation&lt;/code&gt; of communication mechanism.
For example, libraries can handle the implementation of REST, or gRPC or pushing queue messages.&lt;/li&gt;
&lt;li&gt;All the other services using client libraries can &lt;code class=&quot;language-text&quot;&gt;avoid the boilerplate code&lt;/code&gt; needed to implement the communication mechanism.&lt;/li&gt;
&lt;li&gt;In typed languages, the library can provide pre-defined &lt;code class=&quot;language-text&quot;&gt;entity classes for the requests and responses&lt;/code&gt;. So, they are essentially self-documented out of the box. And, with a good IDE, implementing such method calls is instinctual.&lt;/li&gt;
&lt;li&gt;Service authors can abstract the &lt;code class=&quot;language-text&quot;&gt;error handling&lt;/code&gt; boilerplate code and have custom, defined error classes.&lt;/li&gt;
&lt;li&gt;It provides control over the &lt;code class=&quot;language-text&quot;&gt;versioning&lt;/code&gt; of internal calls.&lt;/li&gt;
&lt;li&gt;Ease of pushing updates.&lt;/li&gt;
&lt;li&gt;Client libraries can provide &lt;code class=&quot;language-text&quot;&gt;instrumentation&lt;/code&gt;, by including logging of calls, events, errors. Such logs, traces will be useful information to measure performance, latency.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Authors can use code generators to create API client libraries.
For example, for REST APIs, you can check these ー&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/OpenAPITools/openapi-generator&quot;&gt;openapi-generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/swagger-api/swagger-codegen&quot;&gt;swagger-codegen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;So, is this worth the extra engineering effort?&lt;/h3&gt;
&lt;p&gt;Yes, I like to think so. It’ll make my teammates happy to collaborate, and it’ll certainly make me happy to maintain codebases.&lt;/p&gt;
&lt;p&gt;What do you think? I will love to hear your thoughts on this topic.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;#TODO&lt;/strong&gt; Add sample code snippet, link to a service boilerplate repo with API client library setup.&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[#YAGW... yet another git workflow]]></title><description><![CDATA[In this post, I will present a workflow that can help “fast” paced, small teams which are managing multiple projects. It’s a variation of…]]></description><link>https://pratham.sh/yagw-yet-another-git-workflow/</link><guid isPermaLink="false">https://pratham.sh/yagw-yet-another-git-workflow/</guid><pubDate>Fri, 22 May 2020 19:29:33 GMT</pubDate><content:encoded>&lt;p&gt;In this post, I will present a workflow that can help “fast” paced, small teams which are managing multiple projects. It’s a variation of the classic git-flow, with alterations to support simultaneous development and QA testing cycles of many features.&lt;/p&gt;
&lt;p&gt;I have worked with multiple teams, and with every group, we always had a secondary develop environment separate from production. We used this environment for testing before the production release. Many times release of a tested feature would get blocked by other untested feature. It happened because we would merge multiple feature branches into a develop branch, and for production release, we followed the flow to merge develop into master.&lt;/p&gt;
&lt;p&gt;Cherry-picking helped many a time, but it used to get messy. I brainstormed some ideas off my close friend Ankur Bohra, and I will present those ideas here in this article.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/87ba9d5d3b3cb0068f56f25d277db9b7/c1b63/yagw.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 133.78378378378378%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsSAAALEgHS3X78AAACvUlEQVRIx61Wa1PaQBTl//+ldqYf2ql2rIrOiChv8s5uNm9ISPD03k0CFBkV28wc7pLA4dw3PS/JMFYhJkcYKQV+luQFomz9F9JVQShbFDsb07Mek10KF78DD1eywXXg47tvYxQoxMkKMs4QENiG6Qrb7Vaj7mxd4+XlBfm6RI/VMFlfCdy2uCNcShcD14PpSCwcgSVhZvmwfIWiLGFYNlxfwHY8OjtIswzrsmoIWRUT3ZAyBpP/FA4mYYiMXGZV7CrbOF9rZayqrhtbEVhp1il8izDNGsIOTMyx4tiqJIcjQiRt/PjZ2YQdWKkbxJiaHp33n3mf8MjlzioCJ6GguB2qP4uwIWtssanQXRXFMm5/6MOEmlTbNbIVuesJmLYDy3GxMEwqr1S7fh7hgdurYqNrj15QktqzFR7HkMFlUla1zvjJGGpSwtsx3KsN4hwPozksL9hl+tNlw4QiSjGcGnBltCfkXr6i1rsloq/PQ3x5ejwgjJpOORoOHSlnmqKoh4NKTrh8zYNBejvCw+EgSQ27yN2RUFEX5QZVVWmUdOZp88rlDkx4QcOhb1h6OIwWFoaTBea2gOFKymqNPF9RuVgaQga6Ft+N4TSKkJM7HJ+ktdxy/EUum+7aUKY/1nqqSYo6kRR2nWuP24+L/Z96uVMcEGn/cQxfxToxZ/XyvvYyXXc2Ddql7WMwnsOkuPI9XyXnEbIyrrkJJWlhOhqG7WFpuZguTEqY+ARhEGFuOJR9WgdEwOCzvkdKP6VwZtha2XA0w8PTRCv9L4T3g2fc3A8wWzYh2BHy2rxTUhMx7kOpt95xL+9cNhuXbU/C8QPttiak9z1e6D9oB/NuviBVjF9E9s019bLPjhQ6pHA0M0iVTYmwKEGmPo/pHq/aHv87mNIQmBGmLfjMQ4Ofxa9GVqY3nSPDxrZnWyiIMMUfjUPqlOCoKzMAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;YAGW&quot;
        title=&quot;#yagw... yet another git workflow&quot;
        src=&quot;/static/87ba9d5d3b3cb0068f56f25d277db9b7/fcda8/yagw.png&quot;
        srcset=&quot;/static/87ba9d5d3b3cb0068f56f25d277db9b7/12f09/yagw.png 148w,
/static/87ba9d5d3b3cb0068f56f25d277db9b7/e4a3f/yagw.png 295w,
/static/87ba9d5d3b3cb0068f56f25d277db9b7/fcda8/yagw.png 590w,
/static/87ba9d5d3b3cb0068f56f25d277db9b7/efc66/yagw.png 885w,
/static/87ba9d5d3b3cb0068f56f25d277db9b7/c83ae/yagw.png 1180w,
/static/87ba9d5d3b3cb0068f56f25d277db9b7/c1b63/yagw.png 1200w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1. master&lt;/h3&gt;
&lt;p&gt;As it should be, the master branch is the production branch.&lt;/p&gt;
&lt;h3&gt;2. develop&lt;/h3&gt;
&lt;p&gt;The develop branch will have the latest development changes that are ready for QA testing, and targeted to be released to production soon after QA testing.&lt;/p&gt;
&lt;h3&gt;3. feature branches&lt;/h3&gt;
&lt;p&gt;For feature developments, every feature will get a dedicated branch. Create a new feature branch from the master branch.&lt;/p&gt;
&lt;p&gt;Follow a basic naming convention, something like &lt;code class=&quot;language-text&quot;&gt;feature/{{task-id}}-{{short-task-title}}&lt;/code&gt;.&lt;br&gt;
For example, &lt;code class=&quot;language-text&quot;&gt;feature/12-signup&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In addition to this &lt;code class=&quot;language-text&quot;&gt;feature&lt;/code&gt; class, there are other classes like - hotfix, refactor, bugfix, task. Choose one based on the nature of the change.&lt;/p&gt;
&lt;h3&gt;4. Code review&lt;/h3&gt;
&lt;p&gt;The next important step after feature development is code review. One team must not skip this!
Create a pull request from a feature branch to develop branch.&lt;/p&gt;
&lt;p&gt;Alternate strategy (optional) -&lt;br&gt;
Create a separate feature release branch from the master branch, and raise a pull-request from a feature development branch to its release branch.&lt;br&gt;
Follow a basic naming convention, something like &lt;code class=&quot;language-text&quot;&gt;release/feature/{{task-id}}-{{short-task-title}}&lt;/code&gt;.&lt;br&gt;
For example, &lt;code class=&quot;language-text&quot;&gt;release/feature/12-signup&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A strategy to squash development commits is worth considering before raising pull request or before merging to develop.&lt;/p&gt;
&lt;h3&gt;5. QA testing&lt;/h3&gt;
&lt;p&gt;The next crucial step before production deployment is to get the feature tested by the QA team.&lt;/p&gt;
&lt;p&gt;For the testing release, raise a pull request from feature to develop branch. Get approvals from teammates on this release pull request, and then merge it and deploy.&lt;/p&gt;
&lt;p&gt;Avoid squashing commits while merging to develop branch (and master branch).&lt;/p&gt;
&lt;p&gt;QA process will identify issues, missed edge case scenarios in the release. Additional code changes will be needed to fix those issues. Commit those changes on the feature branch. Raise a pull request for code review of new changes, followed by QA testing to validate them.&lt;/p&gt;
&lt;h3&gt;6. Production release&lt;/h3&gt;
&lt;p&gt;Once a feature passes the QA testing process, don’t delay production release.&lt;/p&gt;
&lt;p&gt;Raise a pull request from feature to master branch. Get approvals from teammates on this release pull request, and then merge to master branch and deploy production.&lt;/p&gt;
&lt;h4&gt;So, how will it help?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;It helps in managing releases of simultaneously developed multiple features. It avoids bottleneck on develop branch that can potentially happen through the QA cycle.&lt;/li&gt;
&lt;li&gt;It records each process step in the git history. The merge commit marks the code-review steps. The subsequent commits made after QA testing highlights the importance of QA process identifying issues before the production release.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;And, any cons?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Conflict resolution can get tedious.&lt;/p&gt;
&lt;p&gt;In case of conflicts between feature and develop branch, we can’t pull the develop branch into the feature branch. It might bring other untested code from develop branch into the feature branch.&lt;/p&gt;
&lt;p&gt;A temporary arbitrator branch would be needed to resolve conflicts. Create a new branch from the feature branch. Use this new branch to resolve conflicts by pulling develop branch into it.&lt;/p&gt;
&lt;p&gt;For the arbitrator branch, follow release branch naming convention, something like &lt;code class=&quot;language-text&quot;&gt;release-develop/feature/{{task-id}}-{{short-task-title}}&lt;/code&gt;.&lt;br&gt;
For example, &lt;code class=&quot;language-text&quot;&gt;release-develop/feature/develop/12-signup&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Master branch must be merged into the develop branch after production deployment. This additional step, syncs develop with master and its extra merge commits.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, what do y’all think about this workflow?&lt;/p&gt;</content:encoded></item></channel></rss>